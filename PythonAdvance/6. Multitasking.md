# MultiThreading
1. Multitasking is of two types:
    - Process based multitasking where more than one process can be run parallelly
    - Thread based multitasking where a process is divided into many thread and are can simultaneously

## Multithreading
1. Where each thread is an independent part of the program
2. a flow of execution is known as thread
3. each thread has independent job to perform

## How to know the name of current thread
- threading module needs to be imported
- **threading.current_thread().getName()**
-                import threading
                 print('The Current Thread : ', threading.current_thread().getName())

## Creating Thread in Python
1. There are 3 ways by which we can create a thread
    - Creating a thread without using any class (Functional oriented way)
    - creating a thread by extending Thread class (OOP)
    - creating a thread without extending Thread class (OOP)

2. **Creating a thread without using any class (Functional oriented way)**
    -            from threading import *
                 def display():
                    for i in range(10):
                        print('Child thread: ',i+1)

                 childThread = Thread(target = display)        # creation of thread object to execute display
                 childThread.start()                           # start() enables to start the execution of thread object 
                 for i in range(10):     
                     print('Parent thread: ',i+1)

3. **Creating a thread by extending Thread class (OOP)**
    -            from threading import *
                 class MyThread(Thread)
                    # overriding run() of the Thread class
                    def run(self):
                        for i in range(10):
                            print('Child thread: ',i+1)

                 childThread = MyThread()                      # creation of thread object to execute display
                 childThread.start()                           # start() enables to start the execution of thread object 
                 for i in range(10):     
                     print('Parent thread: ',i+1)                     

4. **Creating a thread without extending Thread class (OOP)**
    -            from threading import *
                 class Test
                    def m1(self):
                        for i in range(10):
                            print('Child thread: ',i+1)
                 
                 test = Test()
                 childThread = Thread(target = test.m1())                      # creation of thread object to execute display
                 childThread.start()                                           # start() enables to start the execution of thread object 
                 for i in range(10):     
                     print('Parent thread: ',i+1)        


## How multithreading improves performance
- without multithreading
    -           import time
                def doubles(numbers):
                    for n in numbers:
                        time.sleep(1)
                        print('Double value: ', 2*n)
                def squares(numbers):
                    for n in numbers:
                        time.sleep(1)
                        print('Square value: ', n*n)

                numbers = [1,2,3,4,5,6,7,8,9]
                beginTime = time.time()
                doubles(numbers)
                squares(numbers)
                endTime = time.time()
                print('Time taken to execute without multithreading: ', endTime - beginTime)        # roughly: 12sec

- with multithreading
    -           import time
                from threading import *
                def doubles(numbers):
                    for n in numbers:
                        time.sleep(1)
                        print('Double value: ', 2*n)
                def squares(numbers):
                    for n in numbers:
                        time.sleep(1)
                        print('Square value: ', n*n)

                numbers = [1,2,3,4,5,6,7,8,9]
                beginTime = time.time()
                t1  = Thread(target = doubles, args = (numbers,))
                t2  = Thread(target = squares, args = (numbers,))

                t1.start()
                t2.start()

                t1.join()                                       #   wait untill t1 thread is completed
                t2.join()                                       #   wait untill t2 thread is completed

                endTime = time.time()
                print('Time taken to execute with multithreading: ', endTime - beginTime)           # roughly: 6sec            